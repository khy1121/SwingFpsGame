# NetFPS 프로젝트 주간 보고서
**작성일**: 2025년 11월 7일  
**작성자**: [김헌영]

---

## 📋 금주 진행한 작업

### 1. 로비 시스템 팀 선택 및 레디 기능 구현
- **팀 선택 UI 개발**
  - RED TEAM / BLUE TEAM 선택 버튼 구현
  - 팀 선택 시 서버와 실시간 동기화
  - 선택한 팀에 플레이어 닉네임 자동 추가

- **레디(Ready) 시스템 구현**
  - READY/CANCEL 토글 버튼 구현
  - 레디 상태 플레이어 목록 배경색 변경 (초록색)
  - 레디 상태에서 팀 변경 잠금 기능

- **게임 시작(START) 검증 로직 구현**
  - 각 팀 최소 1명 이상 필수
  - 팀 간 인원 차이 2명 이하 제한
  - 모든 플레이어 레디 상태 확인
  - 조건 충족 시에만 START 버튼 활성화

### 2. 서버-클라이언트 프로토콜 확장
- **새로운 프로토콜 메시지 추가**
  - `TEAM`: 팀 선택 전송
  - `READY` / `UNREADY`: 레디 상태 토글
  - `TEAM_ROSTER`: 팀 구성원 및 레디 상태 브로드캐스트
  - `START`: 게임 시작 요청
  - `GAME_START`: 서버의 게임 시작 승인 신호

- **서버 측 팀 로스터 관리**
  - 모든 클라이언트에게 실시간 팀 구성 정보 브로드캐스트
  - 게임 시작 조건 검증 및 승인 로직

### 3. UI/UX 개선
- **커스텀 버튼 컴포넌트 개발 (FilledButton)**
  - 전체 배경을 solid color로 채우는 커스텀 버튼 클래스
  - 기본 JButton의 흰색 배경 오버레이 문제 해결
  - 버튼 상태별 시각적 피드백 구현:
    - Normal: 기본 배경색
    - Hover: 5% 밝게
    - Pressed: 40% 어둡게
    - Selected: 노란색 테두리(3px) 추가
    - Disabled: 회색 처리

- **레이아웃 수정**
  - 팀 선택 버튼이 숨겨지는 문제 해결
  - BorderLayout 중첩 구조 개선 (midPanel 래퍼 추가)
  - 맵 선택 → 팀 선택 → 팀 목록/채팅 순서로 명확한 흐름 구성

---

## 🎯 금주 수행결과 및 문제점

### 수행 결과
✅ **성공적으로 구현된 기능**
- 팀 선택 및 레디 시스템 완전 동작
- 서버-클라이언트 간 실시간 상태 동기화
- 게임 시작 검증 로직 정상 작동
- 직관적인 UI/UX 제공 (색상 피드백, 상태 표시)

### 발생한 문제점 및 해결 과정

#### 문제 1: 팀 선택 버튼 숨김 현상
**증상**  
- BorderLayout.CENTER에 맵 선택 패널 추가 후, 같은 위치에 팀 선택 버튼을 추가하려 하자 이전 컴포넌트가 덮어씌워져 버튼이 보이지 않음

**원인**  
- BorderLayout은 각 위치(NORTH, CENTER, SOUTH 등)에 하나의 컴포넌트만 배치 가능
- CENTER 위치에 여러 패널을 직접 추가하려 하여 마지막 패널만 표시됨

**해결 방법**  
```java
// midPanel 래퍼를 생성하여 팀 선택 버튼과 하단 패널을 묶음
JPanel midPanel = new JPanel(new BorderLayout());
midPanel.add(teamSelectPanel, BorderLayout.NORTH);
midPanel.add(bottomPanel, BorderLayout.CENTER);
centerPanel.add(midPanel, BorderLayout.CENTER);
```

#### 문제 2: 버튼 클릭 시 흰색 배경 오버레이
**증상**  
- 기본 JButton 사용 시 hover/pressed 상태에서 흰색 사각형이 나타나 디자인 의도와 다름
- 버튼 전체를 solid color로 채우고자 했으나 `setBackground()`만으로는 불충분

**원인**  
- Swing의 기본 ButtonUI가 `contentAreaFilled` 속성과 Look&Feel에 따라 내부 영역을 별도 렌더링
- 단순히 배경색만 설정해서는 버튼 내부의 흰색 영역이 덮어씌워짐

**해결 방법**  
```java
// FilledButton 커스텀 클래스 생성
private static class FilledButton extends JButton {
    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D g2 = (Graphics2D) g.create();
        // 안티앨리어싱 적용
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, 
                           RenderingHints.VALUE_ANTIALIAS_ON);
        
        // 상태별 색상 계산
        Color fill;
        if (!isEnabled()) {
            fill = disabledBg;
        } else if (getModel().isPressed() || getModel().isSelected()) {
            fill = darker(getBackground(), 0.4f);
        } else if (getModel().isRollover()) {
            fill = brighter(getBackground(), 0.05f);
        } else {
            fill = getBackground();
        }
        
        // 전체 영역을 직접 채움
        g2.setColor(fill);
        g2.fillRoundRect(0, 0, getWidth(), getHeight(), 8, 8);
        
        // 선택 상태면 노란 테두리 추가
        if (getModel().isSelected()) {
            g2.setColor(new Color(255, 220, 0));
            g2.setStroke(new BasicStroke(3));
            g2.drawRoundRect(1, 1, getWidth() - 3, getHeight() - 3, 8, 8);
        }
        
        g2.dispose();
        super.paintComponent(g);
    }
}
```

#### 문제 3: 선택된 버튼의 시각적 구분 부족
**증상**  
- 팀 선택 후 어떤 팀이 선택되었는지 명확하지 않음
- Pressed 상태의 어두운 배경만으로는 선택 지속성이 불명확

**원인**  
- 일반적인 버튼 상태(normal, hover, pressed)만으로는 "현재 선택된" 상태를 표현하기 어려움
- 색상 변화만으로는 시각적 구분이 약함

**해결 방법**  
- ButtonModel의 `isSelected()` 메서드를 활용한 선택 상태 추가
- 선택된 버튼에 노란색(255, 220, 0) 테두리(3px) 렌더링
- `updateTeamButtons()` 메서드에서 `setSelected(true/false)` 호출로 상태 관리

---

## 💡 해결 과정에서 배운 내용

### 1. Java Swing 레이아웃 관리
**BorderLayout의 특성**
- 각 영역(NORTH, SOUTH, EAST, WEST, CENTER)에 하나의 컴포넌트만 배치 가능
- 같은 영역에 여러 컴포넌트를 추가하면 마지막 것만 표시됨
- 복잡한 레이아웃은 패널을 중첩하여 구성해야 함

**레이아웃 디버깅 팁**
- 컴포넌트가 보이지 않을 때는 부모 컨테이너의 레이아웃 구조부터 확인
- 패널에 배경색을 임시로 설정하여 실제 렌더링 영역 확인
- `setPreferredSize()` vs `setSize()` 차이 이해 (레이아웃 매니저 존재 시)

### 2. 커스텀 컴포넌트 렌더링
**paintComponent() 오버라이드 원칙**
```java
@Override
protected void paintComponent(Graphics g) {
    // 1. Graphics2D로 캐스팅 및 복사본 생성 (원본 보호)
    Graphics2D g2 = (Graphics2D) g.create();
    
    // 2. 렌더링 힌트 설정 (안티앨리어싱 등)
    g2.setRenderingHint(...);
    
    // 3. 커스텀 그리기 로직
    g2.fillRoundRect(...);
    
    // 4. Graphics2D 리소스 해제
    g2.dispose();
    
    // 5. 부모 클래스의 paintComponent 호출 (텍스트, 아이콘 렌더링)
    super.paintComponent(g);
}
```

**색상 조작 함수 구현**
- `Color.brighter()` / `darker()`는 고정 비율이므로 정밀한 제어 어려움
- RGB 값을 직접 계산하여 원하는 밝기/어둡기 정확히 조절
- Alpha 채널 유지에 주의 (투명도 보존)

### 3. TCP 소켓 통신 및 프로토콜 설계
**메시지 기반 프로토콜 설계**
- 명령어 구분을 위해 `PREFIX:DATA` 형식 사용
- 복잡한 데이터는 구분자(`;`, `,`)로 직렬화
- 예: `TEAM_ROSTER:player1,0,true;player2,1,false`

**동기화 이슈 처리**
- 서버에서 상태 변경 시 모든 클라이언트에 브로드캐스트 필수
- 클라이언트는 서버의 ROSTER 메시지를 기준으로 UI 업데이트 (단일 진실 공급원)
- 로컬 상태와 서버 상태 불일치 방지

**스레드 안전성**
- Swing은 EDT(Event Dispatch Thread)에서만 UI 업데이트 가능
- 소켓 수신 스레드에서 `SwingUtilities.invokeLater()` 사용 필수
- 게임 시작 시 로비 수신 스레드 종료 (`lobbyListening = false`)

### 4. 상태 관리 및 검증 로직
**클라이언트 측 상태 관리**
```java
private int selectedTeam = -1;           // 팀 선택 상태
private boolean isReady = false;         // 레디 상태
private Map<String, Integer> playerTeams; // 전체 플레이어 팀 정보
private Set<String> readyPlayers;        // 레디한 플레이어 목록
```

**서버 측 검증의 중요성**
- 클라이언트 UI에서 검증해도 서버에서 재검증 필수 (보안, 일관성)
- START 메시지 수신 시 팀 밸런스, 레디 상태 재확인 후 GAME_START 발송

### 5. 사용자 경험(UX) 개선
**상태 피드백의 중요성**
- 버튼 상태(hover, pressed, selected)별 명확한 시각적 구분
- 비활성화 상태는 회색으로 처리하여 클릭 불가 명시
- 레디 플레이어는 초록색 배경으로 즉시 인지 가능

**조작 흐름 설계**
1. 팀 선택 → READY 버튼 활성화
2. READY 상태 → 팀 변경 버튼 비활성화 (실수 방지)
3. 모든 인원 레디 + 팀 밸런스 → START 버튼 활성화
4. START 클릭 → 서버 승인 → 게임 시작

---

## 📅 다음주 예정 작업

### 1. 캐릭터 선택 시스템 구현
- [ ] 캐릭터 선택 UI/UX 디자인
- [ ] 캐릭터별 스탯 및 능력 정의 (`CharacterData.java`)
- [ ] 선택한 캐릭터 정보 서버 전송 및 동기화
- [ ] 캐릭터 중복 선택 제한 로직

### 2. 맵 데이터 로딩 시스템
- [ ] 맵 파일 형식 정의 (JSON, 커스텀 포맷 등)
- [ ] `assets/maps/` 폴더에서 맵 데이터 로딩
- [ ] 맵별 스폰 포인트, 벽, 오브젝트 정보 파싱
- [ ] 게임 패널에 맵 정보 전달 및 렌더링

### 3. 게임 플레이 핵심 기능 개발
- [ ] 플레이어 이동 및 충돌 감지
- [ ] 카메라(시점) 회전 및 렌더링
- [ ] 무기 발사 및 히트 판정
- [ ] 체력 시스템 및 사망/리스폰 처리

### 4. 네트워크 동기화 강화
- [ ] 플레이어 위치/회전 실시간 동기화
- [ ] 발사 이벤트 및 피격 정보 브로드캐스트
- [ ] 레이턴시 보정 및 예측 이동 구현
- [ ] 서버 권한 검증 (치트 방지)

### 5. UI/UX 추가 개선
- [ ] 게임 내 HUD (체력, 탄약, 미니맵 등)
- [ ] 스코어보드 (팀별 점수, K/D/A)
- [ ] 게임 종료 화면 (승리/패배, MVP 등)
- [ ] 사운드 이펙트 및 배경음악 추가

### 6. 테스트 및 최적화
- [ ] 다중 클라이언트 동시 접속 테스트
- [ ] 네트워크 지연 시뮬레이션 및 안정성 검증
- [ ] 메모리 누수 및 성능 프로파일링
- [ ] 예외 처리 및 에러 복구 로직 강화

---


## 📝 참고 사항

### 컴파일 및 실행 방법
```powershell
# 컴파일
javac -encoding UTF-8 -d bin -sourcepath src -cp bin src\com\fpsgame\server\GameServer.java
javac -encoding UTF-8 -d bin -sourcepath src -cp bin src\com\fpsgame\client\LobbyFrame.java

# 서버 실행
java -cp bin com.fpsgame.server.GameServer

# 클라이언트 실행 (여러 창)
java -cp bin com.fpsgame.client.MainLauncher
```

### 주요 파일 구조
```
NetFps/
├── src/com/fpsgame/
│   ├── client/
│   │   ├── LobbyFrame.java      # 로비 UI 및 팀/레디 시스템
│   │   ├── GamePanel.java       # 게임 플레이 화면
│   │   └── MainLauncher.java    # 클라이언트 진입점
│   ├── server/
│   │   └── GameServer.java      # 서버 로직 및 프로토콜 처리
│   └── common/
│       ├── GameConstants.java   # 상수 정의
│       ├── Protocol.java        # 프로토콜 메시지
│       └── CharacterData.java   # 캐릭터 데이터
└── bin/                         # 컴파일된 클래스 파일
```

---

**다음 보고 예정일**: 미정
